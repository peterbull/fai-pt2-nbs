# AUTOGENERATED! DO NOT EDIT! File to edit: ../../03.02_gpt_teach_nn.ipynb.

# %% auto 0
__all__ = ['n_samples', 'loan_amount', 'term', 'interest_rate', 'income', 'credit_score', 'x', 'y', 'model', 'lr', 'optimizer',
           'epochs', 'SimpleNet', 'mse']

# %% ../../03.02_gpt_teach_nn.ipynb 7
import torch
torch.set_printoptions(precision=4, linewidth=140, threshold=500, sci_mode=False)

# %% ../../03.02_gpt_teach_nn.ipynb 9
n_samples = 1000
loan_amount = torch.normal(5000., 1500, size=(n_samples,))  # average loan amount is $5000
term = torch.randint(12, 60, size=(n_samples,))  # loan term varies between 1 and 5 years
interest_rate = torch.normal(0.05, 0.01, size=(n_samples,))  # average interest rate is 5%
income = torch.normal(50000, 10000, size=(n_samples,))  # average income is $50,000
credit_score = torch.normal(600, 50, size=(n_samples,))  # average credit score is 600

# %% ../../03.02_gpt_teach_nn.ipynb 11
x = torch.column_stack([loan_amount, term, interest_rate, income, credit_score]).float()
y = torch.distributions.categorical.Categorical(torch.tensor([0.9, 0.1])).sample((n_samples,)).float()

# %% ../../03.02_gpt_teach_nn.ipynb 17
y = y[:, None]

# %% ../../03.02_gpt_teach_nn.ipynb 22
import torch.nn.functional as F

class SimpleNet(torch.nn.Module):
    def __init__(self):
        super(SimpleNet, self).__init__()
        self.lin_1 = torch.nn.Linear(5, 3)
        self.lin_2 = torch.nn.Linear(3, 1)

    def forward(self, x):
        x = self.lin_1(x)
        x = F.relu(x)
        x = self.lin_2(x)
        output = torch.sigmoid(x)
        return output

# %% ../../03.02_gpt_teach_nn.ipynb 23
model = SimpleNet()

# %% ../../03.02_gpt_teach_nn.ipynb 25
def mse(output, target):
    return (output - target).pow(2).mean()

# %% ../../03.02_gpt_teach_nn.ipynb 27
lr = 1e-2

# %% ../../03.02_gpt_teach_nn.ipynb 28
optimizer = torch.optim.SGD(model.parameters(), lr=lr)

# %% ../../03.02_gpt_teach_nn.ipynb 30
from tqdm import tqdm

epochs = 100

for epoch in tqdm(range(epochs)):
    preds = model(x)
    loss = mse(preds, y)
    print(f"Epoch: {epoch}, Loss: {loss}", flush=True)
    loss.backward()
    optimizer.step()
    optimizer.zero_grad()
